<#
    This script searches hosts (defined in the $Computers file below as 'user,hostname') for all .jar files,
    copies them to C:\temp\log4j, and searches them for the vulnerable 'JndiLookup.class' Java class. This is the
    vulnerability exploited by Log4Shell (https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2021-44228).

    !!IMPORTANT!!
    This script does not remediate Log4Shell. If the vulnerability is found in one of the archives, the host will
    still need manual remediation.
#>

## Path to .csv with 'user,hostname' contents, import machines to scan
$Computers = Import-CSV ".\computers.csv"

## Uncomment if authentication is necessary. It does not seem to be if running as a domain admin
## Get username of script executor
# $ScriptUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
## Prompt for credentials
# $Credentials = Get-Credential $ScriptUser

## Location to save reports on this machine (i.e. NOT remote)
$FileshareLoc = "C:\temp"

## Initialize array to store machines script was able to execute on
$ScriptSuccess = @()
## File to output $ScriptSuccess arr to
$SuccessCsv = "c:\temp\_log4shell_vulnerability_scan_status.csv"

## Scriptblock to send & execute cleanup commands on remote
$CleanupScript = {

    $TempDirectory = "C:\temp\log4j"

    ## Cleanup $TempDirectory
    Remove-Item "$TempDirectory" -Recurse -Force
    Remove-Item "$TempDirectory\*.csv" -Force

}

## Scriptblock to send & execute on remote
$Script = {

    ## Fileshare location to store CSVs with vulnerable files
    # $FileshareLoc = "//EPI-HDJ-9NVSPNE/Reports"
    ## Location to save reports on this machine (i.e. NOT remote)
    $FileshareLoc = "C:\temp"

    Write-Host "[DEBUG] Remote location: $FileshareLoc"

    ## Get hostname of remote machine, set in variable
    $RemoteHostname = hostname
    # Write-Host "[DEBUG] Hostname: $RemoteHostname"

    ## Store location to c:\users\<current_user>\Documents
    # [string]$RemoteDocumentsDir = [Environment]::GetFolderPath("MyDocuments")

    ## Import library to open ZIP files
    Add-Type -Assembly "System.IO.Compression.Filesystem"

    ## Get current release from "All Everything Downloads" at: https://www.voidtools.com/
    $EverythingVersion = "Everything-1.4.1.1020.x64.zip"
    ## Build download URL
    $PortableEverythingURL = "https://www.voidtools.com/$EverythingVersion"
    ## C:\users\<scriptuser>
    $ExpandedDirectory = "$($ENV:TEMP)\Everything"
    ## Temp directory to store found JAR files to scan
    $TempDirectory = "C:\Temp\Log4j"

    ## Vulnerable file name
    $Vuln = "JndiLookup.class"

    ## Timestamp
    [String]$ts = Get-Date -Format "yyyy-MM-dd_HH-mm"

    ## Name of CSV to output found vulnerable classes
    [string]$vulnerabilities_csv = $($RemoteHostname) + "_$ts" + "_found_jars.csv"
    Write-Host "[DEBUG] Vulnerabilities CSV:" $vulnerabilities_csv

    ## Ensure $ExpandedDirectory exists on remote
    If (-Not (Test-Path -Path $ExpandedDirectory)) {
        New-Item -Path $ExpandedDirectory -ItemType Directory
    }

    ## Ensure $TempDirectory exists on remote
    If (-Not (Test-Path -Path $TempDirectory)) {
        New-Item -Path $TempDirectory -ItemType Directory
    }

    # Write-Host"[DEBUG] Install Everything on remote"

    ## Wget Everything portable & install, if not present on remote
    If (-Not (Test-Path -Path "$ExpandedDirectory\Everything\Everything.exe" -PathType Leaf)) {
        Set-PSRepository -Name 'PSGallery' -InstallationPolicy Trusted
        Invoke-WebRequest -UseBasicParsing -Uri $PortableEverythingURL -OutFile "$ExpandedDirectory\Everything.zip"
        Expand-Archive "$ExpandedDirectory\Everything.zip" -DestinationPath $ExpandedDirectory -Force

        ## Ensure Everything service is not running, install PSEverything module
        if (!(Get-Service "Everything Client" -ErrorAction SilentlyContinue)) {
            & "$ExpandedDirectory\everything.exe" -install-client-service
            & "$ExpandedDirectory\everything.exe" -reindex
            start-sleep 3
            Install-Module PSEverything
        }
        ## Everything already installed, install PSEverything module
        else {
            & "$ExpandedDirectory\everything.exe" -reindex
            Install-Module PSEverything
        }
    }
    else {
        Write-Host "'Everything' already installed, skipping."
    }
    
    # Write-Host"[DEBUG] Scanning remote with Everything"

    ## Run scan with everything, search for all .jar files. Exclude recycle bin from search
    $ScanResults = search-everything -global -extension jar folders:C:\, !C:\`$RECYCLE.BIN

    ## Store original paths of found .jar files & vulnerability status
    $FoundJars = @()

    ## If .jar files found
    If ($ScanResults) {
        
        # Write-Host "All Results with vulnerable class:"
        Write-Host "Searching jar files for"$Vuln
        
        ## Not sure this line is necessary
        # ($ScanResults | ForEach-Object { Select-String $Vuln $_ }).path
        
        ## Loop over .jar files in $ScanResults, move to $TempDirectory, convert to .zip, scan .zip for vulnerability
        ForEach ($result in $ScanResults) {
            # Write-Host "[DEBUG] Result:" $result
            
            ## Get name of file without extension
            $basename = (Get-Item "$result").Basename
            # Write-Host "[DEBUG] Basename: "$basename
            
            ## Set new filename for .zip
            $result_zip = "$basename.zip"
            # Write-Host "[DEBUG] Zip name: "$result_zip

            ## Path to zip file in $TempDirectory
            $TempFile = "$TempDirectory\$result_zip"
            # Write-Host "[DEBUG] Tempfile:" $TempFile

            ## Copy .zip to $TempDirectory
            If (-Not (Test-Path -Path "$TempFile" -PathType Leaf)) {

                # Write-Host "[DEBUG] Copy $result to $TempDirectory"
                Copy-Item -Path $result -Destination "$TempFile"
            }

            ## Check for $Vuln in archive
            $archive = [IO.Compression.ZipFile]::OpenRead("$TempFile").Entries

            ## Loop over files in .zip archive
            ForEach ($File in $archive) {

                # Write-Host "[DEBUG] Building object for" $File

                ## Create new object with file's name, relative path, & file ext
                $Object = New-Object -TypeName PSObject
                $Object | Add-Member -MemberType NoteProperty -Name Filename -Value $file.name
                $Object | Add-Member -MemberType NoteProperty -Name FullPath $file.FullName
                $Object | Add-Member -MemberType NoteProperty -Name Extension -Value ([System.IO.Path]::GetExtension($file.FullName))

                ## Check for .class files
                If ($Object.Extension -eq ".class") {
                    # Write-Host "Class file found: "$Object.FileName

                    ## If .class file matches name of $Vuln
                    If ($Object.Filename -eq $Vuln) {
                        Write-Host "Vulnerability found in: "$Object.FullPath

                        ## Add to $FoundJars array
                        $FoundJars += New-Object psobject -Property @{
                            hostname      = $RemoteHostname
                            original_path = $result
                            scan_location = $TempFile
                            vulnerable    = "yes"
                        }
                    }
                }
            }

            # Write-Host "[DEBUG] Writing found vulnerable files to" "$($PWD)\$vulnerabilities_csv"
            ## Output results to CSV
            $FoundJars | Export-CSV $vulnerabilities_csv -NoTypeInformation

        }

        ## Move $vulnerabilities_csv to c:\temp
        Move-Item -Path $vulnerabilities_csv -Destination c:\temp\log4j

        ## Stop & remove 'Everything'
        Get-Process Everything | Stop-Process -Force
        & "$ExpandedDirectory\everything.exe" -uninstall-client-service
        Start-Sleep 2
        Remove-Item $ExpandedDirectory -Recurse -Force

    }
}

## Ensure $FileshareLoc exists on local machine
If (-Not (Test-Path -Path $FileshareLoc)) {
    New-Item -Path $FileshareLoc -ItemType Directory
}

## Loop over computers.csv, run $Script block on remote for each computer
# ForEach ($Computer in $Computers) {
#     Write-Host "Running script on:" $Computer.hostname
#     # Invoke-Command -ComputerName $Computer.hostname -Credential $Credentials -ScriptBlock $Script

#     ## Open Powershell session on remote $Computer.hostname
#     $s = New-PSSession -ComputerName $Computer.hostname

#     ## Run $Script block on remote host
#     Invoke-Command -Session $s -ScriptBlock $Script

#     Write-Host "Copy vulnerabilities CSV to $FileshareLoc on this computer"
#     ## Copy found vulnerabilities to $FileshareLoc
#     Copy-Item C:\temp\*_found_jars.csv -Destination $FileShareLoc -FromSession $s

#     ## Close remote PSSession
#     Remove-PSSession $s

# }

ForEach ($Computer in $Computers) {

    If (Test-Connection $Computer.hostname -quiet -count 1) {

        try {

            Write-Host "Running script on:" $Computer.hostname
            # Invoke-Command -ComputerName $Computer.hostname -Credential $Credentials -ScriptBlock $Script

            ## Open Powershell session on remote $Computer.hostname
            $s = New-PSSession -ComputerName $Computer.hostname -ErrorVariable ErrVar -ErrorAction Stop

            ## Run $Script block on remote host
            Invoke-Command -Session $s -ScriptBlock $Script -ErrorVariable ErrVar -ErrorAction Stop

            Write-Host "Copy vulnerabilities CSV to $FileshareLoc on this computer"

            ## Copy found vulnerabilities to $FileshareLoc
            Copy-Item C:\temp\log4j\*_found_jars.csv -Destination $FileShareLoc -FromSession $s -ErrorVariable ErrVar -ErrorAction Stop

            ## Close remote PSSession
            Remove-PSSession $s -ErrorVariable ErrVar -ErrorAction Stop

            $ScriptSuccess += New-Object psobject -property @{
                Workstation = $Computer.hostname
                Status      = "Success"
                Error       = "NA"

            }
        }
        catch {

            $ScriptSuccess += New-Object psobject -property @{
                Workstation = $Computer.hostname
                Status      = "Error"
                Error       = $ErrVar
            }

        }

    }
    else {

        $ScriptSuccess += New-Object psobject -property @{
            Workstation = $Computer.hostname
            Status      = "Offline"
            Error       = "NA"
        }

    }
}

## Write $ScriptSuccess to CSV
$ScriptSuccess | Select-Object Workstation, status, Error | Sort-Object Workstation | Export-CSV $SuccessCsv -NoTypeInformation

## Run Cleanup
ForEach ($Computer in $Computers) {

    If (Test-Connection $Computer.hostname -quiet -count 1) {

        try {

            Write-Host "Running cleanup on:" $Computer.hostname

            ## Open Powershell session on remote $Computer.hostname
            $s = New-PSSession -ComputerName $Computer.hostname -ErrorVariable ErrVar -ErrorAction Stop

            ## Run $Script block on remote host
            Invoke-Command -Session $s -ScriptBlock $CleanupScript -ErrorVariable ErrVar -ErrorAction Stop

        }
        catch {

            Write-Error "Unable to run cleanup on" $Computer.hostname

        }

    }
    else {

        Write-Error "Cannot connect to $($Computer.hostname)"

    }
}